/**
 * ProjectDocService - Tessy Antigravity Core
 * Sprint 1.3 Parte B: IDE Procedural Documentation
 * 
 * Generates automatic documentation for projects developed in Tessy IDE:
 * - README.md
 * - CHANGELOG.md
 * - API Documentation (from JSDoc/TSDoc)
 */

import { db } from './dbService';

// Types
export interface ProjectDocConfig {
    projectId: string;
    includeReadme: boolean;
    includeChangelog: boolean;
    includeApiDocs: boolean;
    templateStyle: 'minimal' | 'standard' | 'detailed';
}

export interface FileAnalysis {
    path: string;
    language: string;
    exports: string[];
    imports: string[];
    functions: FunctionDoc[];
    classes: ClassDoc[];
}

export interface FunctionDoc {
    name: string;
    params: ParamDoc[];
    returns: string;
    description: string;
    line: number;
}

export interface ClassDoc {
    name: string;
    methods: FunctionDoc[];
    properties: PropertyDoc[];
    description: string;
    line: number;
}

export interface PropertyDoc {
    name: string;
    type: string;
    description: string;
}

export interface ParamDoc {
    name: string;
    type: string;
    description: string;
}

class ProjectDocService {
    /**
     * Generate README.md for a project
     */
    async generateReadme(projectId: string, style: 'minimal' | 'standard' | 'detailed' = 'standard'): Promise<string> {
        const project = await db.projects.get(projectId);
        if (!project) throw new Error('Project not found');

        const conversations = await db.conversations
            .where('projectId')
            .equals(projectId)
            .toArray();

        const templates = await db.templates
            .where('projectId')
            .equals(projectId)
            .toArray();

        let readme = '';

        // Header
        readme += `# ${project.name}\n\n`;
        if (project.description) {
            readme += `${project.description}\n\n`;
        }

        // Badges (if detailed)
        if (style === 'detailed') {
            readme += `![Status](https://img.shields.io/badge/status-active-success.svg)\n`;
            readme += `![Conversations](https://img.shields.io/badge/conversations-${conversations.length}-blue.svg)\n\n`;
        }

        // Table of Contents (if standard or detailed)
        if (style !== 'minimal') {
            readme += `## üìã Table of Contents\n\n`;
            readme += `- [About](#about)\n`;
            readme += `- [Getting Started](#getting-started)\n`;
            if (templates.length > 0) readme += `- [Templates](#templates)\n`;
            readme += `- [Usage](#usage)\n`;
            readme += `- [Development](#development)\n\n`;
        }

        // About
        readme += `## üéØ About\n\n`;
        readme += `This project was developed using **Tessy Antigravity IDE**.\n\n`;
        readme += `**Created:** ${new Date(project.createdAt).toLocaleDateString()}\n`;
        readme += `**Last Updated:** ${new Date(project.updatedAt).toLocaleDateString()}\n\n`;

        // Getting Started
        readme += `## üöÄ Getting Started\n\n`;
        readme += `### Prerequisites\n\n`;
        readme += `\`\`\`bash\n`;
        readme += `# Add your prerequisites here\n`;
        readme += `npm install\n`;
        readme += `\`\`\`\n\n`;

        // Templates (if any)
        if (templates.length > 0) {
            readme += `## üìö Templates\n\n`;
            readme += `This project includes ${templates.length} template(s):\n\n`;
            templates.forEach(t => {
                readme += `- **${t.name}**`;
                if (t.description) readme += `: ${t.description}`;
                readme += `\n`;
            });
            readme += `\n`;
        }

        // Usage
        readme += `## üíª Usage\n\n`;
        readme += `\`\`\`bash\n`;
        readme += `# Add usage examples here\n`;
        readme += `npm start\n`;
        readme += `\`\`\`\n\n`;

        // Development (if detailed)
        if (style === 'detailed') {
            readme += `## üõ†Ô∏è Development\n\n`;
            readme += `**Conversations:** ${conversations.length}\n\n`;
            readme += `This project was developed through iterative conversations in Tessy Antigravity.\n\n`;
        }

        // Footer
        readme += `---\n\n`;
        readme += `*Generated by Tessy Antigravity Auto-Documentation Engine*\n`;

        return readme;
    }

    /**
     * Generate CHANGELOG.md for a project
     */
    async generateChangelog(projectId: string): Promise<string> {
        const project = await db.projects.get(projectId);
        if (!project) throw new Error('Project not found');

        const conversations = await db.conversations
            .where('projectId')
            .equals(projectId)
            .toArray();

        // Sort by date
        conversations.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());

        let changelog = '';

        // Header
        changelog += `# Changelog\n\n`;
        changelog += `All notable changes to **${project.name}** will be documented in this file.\n\n`;

        // Group by date
        const byDate = new Map<string, typeof conversations>();
        conversations.forEach(conv => {
            const date = new Date(conv.createdAt).toISOString().split('T')[0];
            if (!byDate.has(date)) byDate.set(date, []);
            byDate.get(date)!.push(conv);
        });

        // Generate entries
        byDate.forEach((convs, date) => {
            changelog += `## [${date}]\n\n`;
            convs.forEach(conv => {
                const title = conv.title || 'Untitled conversation';
                changelog += `### ${title}\n\n`;
                if (conv.messages && conv.messages.length > 0) {
                    const firstUserMsg = conv.messages.find(m => m.role === 'user');
                    if (firstUserMsg) {
                        const preview = firstUserMsg.content.substring(0, 100);
                        changelog += `- ${preview}${firstUserMsg.content.length > 100 ? '...' : ''}\n`;
                    }
                }
                changelog += `\n`;
            });
        });

        // Footer
        changelog += `---\n\n`;
        changelog += `*Generated by Tessy Antigravity Auto-Documentation Engine*\n`;

        return changelog;
    }

    /**
     * Analyze a code file for documentation extraction
     * (Placeholder - would need actual parser integration)
     */
    async analyzeFile(filePath: string, content: string): Promise<FileAnalysis> {
        const language = this.detectLanguage(filePath);

        // Basic analysis (would be enhanced with actual parsers)
        const analysis: FileAnalysis = {
            path: filePath,
            language,
            exports: [],
            imports: [],
            functions: [],
            classes: []
        };

        // Simple regex-based extraction (placeholder)
        if (language === 'typescript' || language === 'javascript') {
            // Extract function declarations
            const funcRegex = /(?:export\s+)?(?:async\s+)?function\s+(\w+)\s*\((.*?)\)/g;
            let match;
            while ((match = funcRegex.exec(content)) !== null) {
                analysis.functions.push({
                    name: match[1],
                    params: this.parseParams(match[2]),
                    returns: 'unknown',
                    description: '',
                    line: content.substring(0, match.index).split('\n').length
                });
            }

            // Extract class declarations
            const classRegex = /(?:export\s+)?class\s+(\w+)/g;
            while ((match = classRegex.exec(content)) !== null) {
                analysis.classes.push({
                    name: match[1],
                    methods: [],
                    properties: [],
                    description: '',
                    line: content.substring(0, match.index).split('\n').length
                });
            }
        }

        return analysis;
    }

    /**
     * Generate API documentation from file analysis
     */
    async generateApiDocs(projectId: string): Promise<string> {
        // Placeholder - would integrate with file system access
        let apiDocs = '';

        apiDocs += `# API Documentation\n\n`;
        apiDocs += `*Auto-generated from code analysis*\n\n`;

        // Would iterate through project files and analyze
        apiDocs += `## Functions\n\n`;
        apiDocs += `Documentation would be generated here from JSDoc/TSDoc comments.\n\n`;

        apiDocs += `---\n\n`;
        apiDocs += `*Generated by Tessy Antigravity Auto-Documentation Engine*\n`;

        return apiDocs;
    }

    /**
     * Save generated documentation to project
     */
    async saveDocumentation(projectId: string, type: 'readme' | 'changelog' | 'api', content: string): Promise<void> {
        // In a real implementation, this would use File System Access API
        // For now, we'll store in IndexedDB as a template
        const fileName = type === 'readme' ? 'README.md' :
            type === 'changelog' ? 'CHANGELOG.md' :
                'API.md';

        await db.templates.add({
            id: `${projectId}-${type}-${Date.now()}`,
            projectId,
            name: fileName,
            description: `Auto-generated ${type} documentation`,
            content,
            language: 'markdown',
            createdAt: new Date(),
            updatedAt: new Date()
        });
    }

    // Helper methods
    private detectLanguage(filePath: string): string {
        const ext = filePath.split('.').pop()?.toLowerCase();
        const langMap: Record<string, string> = {
            'ts': 'typescript',
            'tsx': 'typescript',
            'js': 'javascript',
            'jsx': 'javascript',
            'py': 'python',
            'rs': 'rust',
            'go': 'go'
        };
        return langMap[ext || ''] || 'unknown';
    }

    private parseParams(paramsStr: string): ParamDoc[] {
        if (!paramsStr.trim()) return [];

        return paramsStr.split(',').map(p => {
            const trimmed = p.trim();
            const [name, type] = trimmed.includes(':') ? trimmed.split(':') : [trimmed, 'any'];
            return {
                name: name.trim(),
                type: type?.trim() || 'any',
                description: ''
            };
        });
    }
}

export const projectDocService = new ProjectDocService();
